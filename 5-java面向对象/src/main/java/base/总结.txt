面向过程程序设计
    解决问题的时候按照一定的流程
    例:
        大象装冰箱
        1.开门
        2.大象装里面
        3.关门
    过程为本,易于理解,但难以复用,增加代码冗余

面向对象程序设计    将大段的过程拆分为小段,考虑是那个实体做的进行分配
    解决问题是按照现实生活的具体规律来考虑问题
    考虑在这个问题中有多少个实体参与进来
    实体为动作的支配者,没有实体那么动作就发生不了
    例:
        大象装冰箱
        实体:  人  冰箱  大象
        分析每一类个体有什么特点,做了什么事情
            人:   开门,装大象,关门。。。。
            冰箱: 有门,容积。。。。
            大象：大。。。

面向对象
    类和对象
    类---抽象笼统的概念(人类)
        是作为一个模板,用来描述很多对象,具有相同的特征(属性)和行为(方法)
    对象---类中衍生出来的一个具体的个体(某个人)
        与自己的类有相同的特征和行为

    1.需要自己描述一个类(或者其他引用数据类型)描述一个类
    2.利用属性或者方法,描述当前类的形态
    3.创建一个当前类的对象
        操作: 对象.调用属性     进行赋值/取值
              对象.调用方法     执行一次方法
        参考类:  class PersonMain
                 class Person


    类的内部成员:
        属性---静态描述类的特征
        方法---动态描述类的行为
        构造方法---用来创建当前类对象时做事情
        程序块(代码块)---用来创建当前类对象之前做事情

    属性----静态的描述类的特点

        权限修饰符  [特征修饰符]  数据类型  属性名字 [= 值];   不赋值有默认值,一般为0和null

    方法----执行某种行为

        权限修饰符  [特征修饰符]  返回值类型  方法名字([参数列表]) [抛出异常] [{
            方法体;
        }];

        方法中最主要的两个结构 方法参数列表  方法的返回值类型
            参数列表可以理解为方法做事情之前需要提供的条件(可以有多个)
            返回值可以理解为方法做事情之后得到的一个结果(只有一个)

        方法的分类:
            1.无参数无返回值
            2.有参数无返回值
            3.无参数有返回值
            4.有参数有返回值
            参考类:  class PersonMain2
                     class Person

        关于main：
            每一个类中不是必须包含主方法
            主方法不属于任何一个类,主方法属于虚拟机,无法通过存在类的对象调用。

        形参和实参
            形参可以理解为是方法执行时的临时变量空间x
            实参可以理解为是方法调用时传递进去的参数a
            方法调用时会将实参的内容传递给形参
            如果内容是基本类型传递的是值,形参改变，实参不变
            如果内容是引用类型传递的是引用,形参改变，实参跟着改变
            参考类:class NeiCun 和 class NeiCun2

        命名规则和规约
        规则
            字母 数字 符号 中文
            字母 区分大小写
            数字 不能开头
            中文 不推荐使用
        规约
            类名字
                首字母大写,两个单词以上,每一个首字母都大写
                    Test TestOne TestOneTwo
            属性/方法/变量
                驼峰式命名规约,首字母小写两个单词以上第二个以后的每一个首字母大写
                    test testOne testOneTwo
            构造方法
                与类名一致,类中唯一的大写字母开头的方法
            静态常量
                全部字母大写 通过_做具体说明 BOOKSTORE_ADMIN
            包名
                全部字母小写,Java关键字都是小写,注意与关键字不要冲突

        方法的重载
            1.概念    一个类中的一组方法使用相同的方法名,不同的参数列表,这样一组方法构成了方法的重载。
                        每个方法的区别:
                            参数的类型不同 参数的数量不同 参数的顺序不同
            2.作用    为了让使用者便于记忆和调用,只需要一个名字和不同的参数可以产生不同的调用方法。

            3.设计方法重载  对应类：class ArgsReLoad
                调用方法的时候,首先通过方法名字定位方法
                如果方法名字有一致,可以通过参数的数据类型定义方法
                如果没有与传递参数类型一致的方法,系统会自动找到一个参数类型进行转换(自动参数类型转换)。
                如果传递的参数类型需要强制类型转换才能匹配参数则会报错,需要先进行强制类型转换到对应类型再传入参数。

            4.JDK1.5版本之后 动态参数列表
                public void test(int... x)  可以接收0至多个参数,本质上是数组操作,可以通过x[index]调用。
                因此动态参数列表方法不能和对应数组参数方法构成重载。

                动态参数列表只能在一个方法中有一个,并且必须放置在方法参数的末尾。
                public void test(int a,int... x)
                public void test(String b,int... x)     可用

                public void test(int... x,int a)
                public void test(int... x,String b)     不可用,编译报错

    构造方法--创建类的过程中做事情    参考类：class Student 和 class StudentMain
        1.作用: 构造当前类的对象
        2.写法:
            权限修饰符 与类名一致的方法名 (参数列表) [抛出异常] {
                方法体;
                [返回对象;](系统自动操作)
            }
        3.用法: 通过new关键字调用
        4.特点: 1.每个类都有一个构造方法,如果类中没有自己定义,那么就会默认使用这个无参的构造方法,
                 若在方法中定义了任意一个构造方法(即便是带参的构造方法),默认的无参构造方法即被覆盖。
                2.构造方法存在方法重载。

    程序块(代码块)
        1.作用:和普通方法相同。
        2.写法:可以认为程序块是一个没有参数,没有修饰符,没有返回值,没有方法名的一个方法。
                {
                    方法体;
                }
        3.用法:块也需要调用才能执行,我们自己调用不到(因为没有名字)
               每一次我们调用构造方法之前,系统会自动调用一次程序块,使其执行一遍。
        4.特点:没有重载概念,但是可以在类中创建多个程序块,不过依然按照行数先后顺序执行。
        5.程序块可以写程序,用于在一个类的对象创建之前执行.

        静态代码块:
            1.写法:
                static{
                    方法体;
                }
            2.特点:在类加载之前自动执行,之后就不再执行。
            3.用法:可以用于程序的数据初始化。
            4.相比于直接在类中添加数据的优势:直接添加数据操作在类被调用时反复使用,静态代码块只会执行一次,相较有更高性能。

    this关键字的使用:      参考类：class Student 和 class StudentMain
        1.这个关键字可以代替调用属性/方法时的当前的对象
        2.this可以通过.的方式来调用类中的属性或者方法。
        3.this可以调用构造方法,通过this()调用,但是只能在另一个构造方法中进行调用,并且必须放在方法体的第一行。

    方法之间进行来回调用:
        写法可以(编译可用)    但是可能会产生StackOverflowError   栈溢出错误
        Exception(认为规定的一种不正常的现象) 异常
        Error(计算机处理不了的问题) 错误
        对于构造方法不能进行来回调用(编译就不好用)

    关于Scanner
        nextInt(nextFloat,nextByte...)     next    nextLine
        1.读取方式来将,都可以以回车符结束,next方法还以空格结束。
          出了nextLine以外,其余的方法都不读取回车符。
        2.读取返回结果来讲:
            nextInt--->String
            nextFloat--->String
            next--->String
            nextLine--->String
        3.利用包装类做String与基本类型转换问题
            通过包装类进行转换。
            int---Integer
            char---Character
            float---Float
            其余几个都是首字母大写

    注:new得到的对象存在于堆内存中,
       对象中值的存储方式和模板相同,
       但是调用的方法中存储的是方法区中类模板的一个地址。
抽象类:
● 抽象类不能实例化
● 抽象类中不一定有抽象方法,有抽象方法的类一定是抽象类
● 可以有构造方法
    作用:
        当创建子类对象时,给私有属性进行赋值。
● 抽象类的子类
    子类只能继承一个抽象类,之后就不能继承别的所有类了,防止冲突
    要么重写抽象类中的所有抽象方法
    要么是抽象类

接口:
    接口就是一种规则,对行为的抽象
    接口的定义和使用:
         接口用interface关键字来定义
         接口不能实例化
         接口和类之间是实现关系,通过implements关键字表示
         接口的子类:
            要么实现接口中所有方法;
            要么是抽象类,将不需要实现的方法进行抽象。
        注意1: 接口和类的实现关系，可以单实现，也可以多实现。
            public class 类名 implements 接口名1 ,接口名2 {}
        注意2: 实现类还可以在继承一个类的同时实现多个接口。
            public class 类名 extends 父类 implements 接口名1,接口名2 {}
    接口中成员的特点:
        ● 成员变量
            只能是常量
            默认修饰符: public static final
        ● 构造方法:
            没有
        ● 成员方法
            只能是抽象方法
            默认修饰符: public abstract
        ● JDK7以前:接口中只能定义抽象方法。
        ● JDK8的新特性:接口中可以定义有方法体的方法。
        ● JDK9的新特性:接口中可以定义私有方法。
    接口和类之间的关系:
        ● 类和类的关系
        继承关系，只能单继承，不能多继承，但是可以多层继承。
        ● 类和接口的关系
        实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口；
        实现接口的类需要实现所有接口的方法。
        ● 接口和接口的关系
        继承关系，可以单继承，也可以多继承；
        之后实现最后一个接口的类需要实现之前接口继承的所有方法。
    接口中默认方法的定义格式(JDK8新特性):
                格式: public default 返回值类型方法名(参数列表) { }
            接口中默认方法的注意事项:
                1.默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字
                2. public可以省略，default不能省略
                3.如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写
                    多个接口时子类对父类方法和属性的调用问题:
                        原文摘自https://www.cnblogs.com/JSD1207ZX/p/15178154.html
                        super和this在子接口中的使用
                        由于接口不是类，super和this的使用和类将会产生较大的区别。
                        首先我们无法在子接口中使用super，只能使用this。（接口名.super和接口名.this仍旧等价于super和this）
                        而对于父接口，我们无法通过super来调用的情况下，我们必须通过父接口名.super的方式来调用某个父接口。
                        也就是说父接口名.super指向的不是父接口的父接口，而是其本身。
                        这是因为一个接口可以继承多个接口，我们无法直接使用super来指代某一个父接口，
                        所以编译器阻止了super这样的用法，即便只继承了一个父接口，改而使用父接口名.super这样显式的指出哪一个父接口。
                        自己理解:
                        同理易知，一个类可以实现多个接口，我们无法直接使用super来指代某一个父接口，
                        所以编译器阻止了super这样的用法，即便只继承了一个父接口，改而使用父接口名.super这样显式的指出哪一个父接口。

    接口中静态方法的定义格式:
        格式: public static 返回值类型方法名(参数列表) {}
        范例: public static void show() {}
    接口中静态方法的注意事项:
        静态方法只能通过接口名调用，不能通过实现类名或者对象名调用
        public可以省略，static不能省略

    JDK9新增的方法
    接口中私有方法的定义格式:
    普通私有方法
    ● 格式1: private 返回值类型方法名(参数列表){}
      范例1: private void show() {}
    静态私有方法
    ● 格式2: private static返回值类型方法名(参数列表) {}
      范例2: private static void method() {}

    适配器设计模式
        1.当一个接口中抽象方法过多,但是我只要使用其中一部分的时候，就可以适配器设计模式
        2.书写步骤:
        编写中间类XXXAdapter,实现对应的接口
        对接口中的抽象方法进行空实现，让真正的实现类继承中间类，并重写需要用的方法
        为了避免其他类创建适配器类的对象，中间的适配器类用abstract进行修饰。

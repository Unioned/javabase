按操作数数目进行分类
    单目  双目  三目
    a++   a+b  (a>b)?x:y
按照运算符功能分类
    1.算术运算
    +   -   *   /   %(取模)   ++(自增)  --(自减)

    x++ x空间内的值自增一个
        x在需要做值的自增时,会产生一个临时的副本空间(备份),
        ++在变量前面,先自增后备份，iinc;iload;
        ++在变量后面,先备份后自增，iload;iinc;
        之后将备份空间内的值赋值给别的变量,之后会销毁备份空间。

        例：
        int a=1;
        for(int i = 1 ; i < 100 ; i++){
            a = a++;
        }
        a=?;
        答：a = 1;
    2.赋值运算
        = 赋值符号 将=右边的内容(值/引用)存入=左边的变量空间内
        +=  -=  *=  /=  %= 复合型

        例： int x=1;
             x+=1;//和x=x+1相同

             byte x = 1;
             x+=2;//3
             x=x+2;//报错,类型不符,(右侧为表达式,所以表达式=无法自动类型转换)。
                x变量空间取出1 常量区取出2 加法运算 将结果重新存回到x变量空间
                x空间--> 1 8bit
                常量区-->2 32bit
                运算符 + 进行了自动类型提升
                1 8bit ---> 1 32bit
                运算结果为 3 32bit
                但byte为8bit,需要强转
                即: x = (byte)(x+2);
    3.关系运算(比较)
        >
        <
        >=
        <=
        !=
        ==
        instanceof  判断对象是否属于某个类,返回值boolean
    4.逻辑运算
        & 逻辑与       前后两条件同时满足为true
        | 逻辑或       前后两条件满足一个为true
        ^ 逻辑异或     前后两条件不一致为true
        ! 逻辑非       单目运算符,boolean值取反
        && 短路与
            1.什么时候发生短路      当 短路与&& 的前面有false的结果时。
            2.进行了什么操作        跳过了 短路与&& 之后的所有计算过程。
            3.如果发生短路情况,短路与&& 的性能比一般的 逻辑与& 会更好。
            4.&逻辑与 和 &&短路与 从执行的最终结果来说没有区别
            5.短路与&& 不一定提高了性能,只有当前面为false时才会发生短路,才会提高性能
        || 短路或
            同上,false-->true
    5.位bit运算
        &   按位与
        |   按位或
        ^   按位异或
        ~   按位取反
        <<  按位左位移           a << b  相当于乘以2的b次幂
        >>  按位右位移           a >> b  相当于除以2的b次幂
        >>> 按位右位移(无符号)    a >>> b
            -6 二进制  11111111 11111111 11111111 11111010
            -6 >> 1   11111111 11111111 11111111 11111101  保留符号位,符号位为1补1,符号位为0补0
            -6 >>> 1  01111111 11111111 11111111 11111101  不保留符号位,符号位直接补0,因此位移后结果始终为非负数

    int a = 1 和 b = 2 结果互换
        方法一：
            int c  = a;
            a = b;
            b = c;
            容易理解,但产生一个新的内存空间
        方法二：
            a = a+b;//a=3;
            b = a-b;//b=3-2=1;
            a = a-b;//a=3-1=2;
            省略一个新的空间,相对不易理解
            求和过程中可能产生越界
        方法三：
            a = a^b;(001 ^ 010 = 011)//a = a ^ b
            b = a^b;(011 ^ 010 = 001)//b = a ^ b ^ b = a
            a = a^b;(001 ^ 010 = 011)//a = a ^ b ^ b ^ a ^ b = b
            一个数字按位异或同一个数两次,结果的值是不会改变的